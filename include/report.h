#ifndef H_REPORT
#define H_REPORT

#include <string>
#include <vector>

#include <boost/algorithm/string/classification.hpp> // boost::for is_any_of
#include <boost/algorithm/string/split.hpp> // boost::split

using std::string;
using std::vector;

struct ScoredItem {
    string name = "";
    string uniq = "";
    int pts = 0;
};

class ScoringReport {
    private:
        string start_time = "";
        string time_recorded = "";
        string time_left = "";

        vector<ScoredItem> vulns; // pos pts
        vector<ScoredItem> penalties; // neg pts

        string title = ""; // title of practice image
        int max_pts = 0; // max points possible
        int total_vulns = 0; // total # of vulns

    public:
        ScoringReport() = default;
        ScoringReport(const string& data) { // parse data
            vector<string> lines;
            boost::split(lines, data, boost::is_any_of("\n"), boost::token_compress_on);

            if (lines.size() < 3)
                throw std::runtime_error("Report(): invalid report data");
            start_time = lines[0];
            time_recorded = lines[1];
            time_left = lines[2];

            ScoredItem itm;
            vector<string> fields;
            size_t nl = lines.size();
            for (size_t i = 3; i != nl; i++) {
                const string& ln = lines[i];
                fields.clear();
                boost::split(fields, ln, boost::is_any_of(",, "), boost::token_compress_off);
                if (fields.size() != 3) continue;

                itm.name = fields[0];
                itm.uniq = fields[1];
                itm.pts = std::atoi(fields[2].c_str());

                if (itm.pts > 0) vulns.push_back(itm);
                else if (itm.pts < 0) penalties.push_back(itm);
            }
        }

        // returns human-readable data
        string to_string(bool use_uniq = false) const {
            // TODO: implement
            std::stringstream ss;
            ss << (title.empty()? "Practice Image" : title);
            ss << " Scoring Report\n\n";

            ss << "Timestamp: " << time_recorded << "\n"
                << "Start time: " << start_time << "\n"
                << "Time Left: " << time_left << "\n\n";

            ss << "Score: " << pts() << " / " << max_pts << " pts\n";
            if (penalties.size())
                ss << "  - Penalties: " << penal_pts() << " pts\n";
            if (vulns.size())
                ss << "  - Vulnerabilities: " << vulns_pts() << " pts\n";
            ss << "\n";

            auto add_list = [&] (const vector<ScoredItem> ls) {
                for (const auto& itm : ls) {
                    ss << "  - " << itm.name;
                    if (use_uniq && itm.uniq.size())
                        ss << " [" << itm.uniq << "]";
                    ss <<" (" << itm.pts << " pts)\n";
                }
            };

            if (penalties.size()) {
                ss << "Got " << penalties.size() << " penalties\n";
                add_list(penalties);
                ss << '\n';
            }

            if (vulns.size()) {
                ss << "Fixed " << vulns.size() << " out of "
                    << total_vulns << " vulnerabilities\n";
                add_list(vulns);
                ss << '\n';
            }

            ss << "Generated by imsc. \n";
            return ss.str();
        }

        void set_title(const string& s) { title = s; }
        void set_max_pts(int p) { max_pts = p; }
        void set_total_vulns(int n) { total_vulns = n; }
        void set_start_time(const string& s) { start_time = s; }
        void set_time_recorded(const string& s) { time_recorded = s; }
        void set_time_left(const string& s) { time_left = s; }

        string summary() const {
            std::stringstream ss;
            ss << "total: " << pts() << " pts\n"
                << vulns.size()
                << " vulns "
                << vulns_pts() << " pts\n"
                << penalties.size()
                << penal_pts() << " pts\n";
            return ss.str();
        }

        // returns parsable data
        string data() const {
            string d = "";
            d += start_time + "\n";
            d += time_recorded + "\n";
            d += time_left + "\n";
            for (const auto& itm : vulns) {
                d += itm.name + ",, " 
                    + itm.uniq + ",, "
                    + std::to_string(itm.pts) + "\n";
            }
            for (const auto& itm : penalties) {
                d += itm.name + ",, " 
                    + itm.uniq + ",, "
                    + std::to_string(itm.pts) + "\n";
            }
            return d;
        }

        int pts() const { return penal_pts() + vulns_pts(); }

        int penal_pts() const {
            int pts = 0;
            for (const auto& itm : penalties)
                pts += itm.pts;
            return pts;
        }

        int vulns_pts() const {
            int pts = 0;
            for (const auto& itm : vulns)
                pts += itm.pts;
            return pts;
        }

        // gotta make loss stand out
        bool lost_since(const ScoringReport& last) const {
            // basic method
            return penal_pts() < last.penal_pts()
                || vulns_pts() < last.vulns_pts();
        }

        bool gained_since(const ScoringReport& last) const {
            return penal_pts() >= last.penal_pts()
                && vulns_pts() >= last.vulns_pts();
        }

        void add_item(const ScoredItem& itm) {
            if (itm.pts > 0) vulns.push_back(itm);
            else if (itm.pts < 0) penalties.push_back(itm);
        }
};

#endif
