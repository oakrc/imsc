#include "report.h"

#include <sstream>

#include <boost/algorithm/string/classification.hpp> // boost::is_any_of
#include <boost/algorithm/string/split.hpp> // boost::split

using std::string;
using std::vector;

ScoringReport::ScoringReport(const string& data) { // parse data
    vector<string> lines;
    boost::split(lines, data, boost::is_any_of("\n"), boost::token_compress_on);

    if (lines.size() < 3)
        throw std::runtime_error("Report(): invalid report data");
    start_time = lines[0];
    time_recorded = lines[1];
    time_left = lines[2];

    ScoredItem itm;
    vector<string> fields;
    size_t nl = lines.size();
    for (size_t i = 3; i != nl; i++) {
        const string& ln = lines[i];
        fields.clear();
        boost::split(fields, ln, boost::is_any_of(",, "), boost::token_compress_off);
        if (fields.size() != 3) continue;

        itm.name = fields[0];
        itm.uniq = fields[1];
        itm.pts = std::atoi(fields[2].c_str());

        if (itm.pts > 0) vulns.push_back(itm);
        else if (itm.pts < 0) penalties.push_back(itm);
    }
}

string ScoringReport::to_string(bool use_uniq) const {
    // TODO: implement
    std::stringstream ss;
    ss << (title.empty()? "Practice Image" : title);
    ss << " Scoring Report\n\n";

    ss << "Timestamp: " << time_recorded << "\n"
        << "Start time: " << start_time << "\n"
        << "Time Left: " << time_left << "\n\n";

    ss << "Score: " << pts() << " / " << max_pts << " pts\n";
    if (penalties.size())
        ss << "  - Penalties: " << penal_pts() << " pts\n";
    if (vulns.size())
        ss << "  - Vulnerabilities: " << vulns_pts() << " pts\n";
    ss << "\n";

    auto add_list = [&] (const vector<ScoredItem> ls) {
        for (const auto& itm : ls) {
            ss << "  - " << itm.name;
            if (use_uniq && itm.uniq.size())
                ss << " [" << itm.uniq << "]";
            ss <<" (" << itm.pts << " pts)\n";
        }
    };

    if (penalties.size()) {
        ss << "Got " << penalties.size() << " penalties\n";
        add_list(penalties);
        ss << '\n';
    }

    if (vulns.size()) {
        ss << "Fixed " << vulns.size() << " out of "
            << total_vulns << " vulnerabilities\n";
        add_list(vulns);
        ss << '\n';
    }

    ss << "Generated by imsc. \n";
    return ss.str();
}

string ScoringReport::summary() const {
    std::stringstream ss;
    ss << "total: " << pts() << " pts\n"
        << vulns.size()
        << " vulns "
        << vulns_pts() << " pts\n"
        << penalties.size()
        << penal_pts() << " pts\n";
    return ss.str();
}

// returns parsable data
string ScoringReport::data() const {
    string d = "";
    d += start_time + "\n";
    d += time_recorded + "\n";
    d += time_left + "\n";
    for (const auto& itm : vulns) {
        d += itm.name + ",, " 
            + itm.uniq + ",, "
            + std::to_string(itm.pts) + "\n";
    }
    for (const auto& itm : penalties) {
        d += itm.name + ",, " 
            + itm.uniq + ",, "
            + std::to_string(itm.pts) + "\n";
    }
    return d;
}

int ScoringReport::penal_pts() const {
    int pts = 0;
    for (const auto& itm : penalties)
        pts += itm.pts;
    return pts;
}

int ScoringReport::vulns_pts() const {
    int pts = 0;
    for (const auto& itm : vulns)
        pts += itm.pts;
    return pts;
}

// NOTE: prefers reporting loss than gain
bool ScoringReport::lost_since(const ScoringReport& last) const {
    // basic method
    return penal_pts() < last.penal_pts()
        || vulns_pts() < last.vulns_pts();
}

bool ScoringReport::gained_since(const ScoringReport& last) const {
    return penal_pts() >= last.penal_pts()
        && vulns_pts() >= last.vulns_pts();
}

void ScoringReport::add_item(const ScoredItem& itm) {
    if (itm.pts > 0) vulns.push_back(itm);
    else if (itm.pts < 0) penalties.push_back(itm);
}
